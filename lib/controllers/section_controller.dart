import 'dart:convert';
import 'package:shelf/shelf.dart';
import 'package:shelf_router/shelf_router.dart';
import 'package:postgres/postgres.dart';
import '../models/section_model.dart'; // Assuming Section model uses json_serializable

/// Controller for handling section-related API endpoints.
/// This controller assumes authentication and authorization are handled by middleware.
class SectionController {
  final PostgreSQLConnection _db;

  /// Constructor requiring a database connection.
  SectionController(this._db);

  /// Creates a Shelf Router instance with all section-related routes.
  Router get router {
    final router = Router();

    // Define routes for section CRUD operations
    router.get('/', _getAllSections);       // Get all sections
    router.get('/<id>', _getSectionById);   // Get a specific section by ID
    router.post('/', _createSection);      // Create a new section
    router.put('/<id>', _updateSection);    // Update an existing section by ID
    router.delete('/<id>', _deleteSection); // Delete a section by ID

    return router;
  }

  // --- Private Route Handlers ---

  /// Handles GET / requests to fetch all sections.
  Future<Response> _getAllSections(Request request) async {
    try {
      final results = await _db.query('SELECT * FROM sections ORDER BY id');
      
      // Use Section.fromJson which should be generated by json_serializable
      final sections = results
          .map((row) => Section.fromJson(row.toColumnMap()))
          .toList();

      return _jsonResponse(200, sections);
    } catch (e, stackTrace) {
      print('Error getting all sections: $e\n$stackTrace');
      return _jsonErrorResponse(500, 'Failed to fetch sections.');
    }
  }

  /// Handles GET /<id> requests to fetch a specific section.
  Future<Response> _getSectionById(Request request, String id) async {
    final sectionId = int.tryParse(id);
    if (sectionId == null) {
      return _jsonErrorResponse(400, 'Invalid section ID format.');
    }

    try {
      final results = await _db.query(
        'SELECT * FROM sections WHERE id = @id',
        substitutionValues: {'id': sectionId},
      );

      if (results.isEmpty) {
        return _jsonErrorResponse(404, 'Section with ID $sectionId not found.');
      }

      final section = Section.fromJson(results.first.toColumnMap());
      return _jsonResponse(200, section);
    } catch (e, stackTrace) {
      print('Error getting section by ID $sectionId: $e\n$stackTrace');
      return _jsonErrorResponse(500, 'Failed to fetch section.');
    }
  }

  /// Handles POST / requests to create a new section.
  Future<Response> _createSection(Request request) async {
    try {
      final jsonBody = await request.readAsString();
      final Map<String, dynamic> body = jsonDecode(jsonBody);

      // Basic validation
      final validationError = _validateSectionPayload(body);
      if (validationError != null) {
        return _jsonErrorResponse(400, validationError);
      }

      // Create Section instance from payload
      // Note: ID, createdAt, updatedAt are typically handled by the database
      final section = Section.fromJson(body);

      final result = await _db.query(
        '''
        INSERT INTO sections (title, content, "imageUrl")
        VALUES (@title, @content, @imageUrl)
        RETURNING *
        ''',
        // Use toJson() which should be generated by json_serializable
        substitutionValues: section.toJson(), 
      );

      final createdSection = Section.fromJson(result.first.toColumnMap());
      return _jsonResponse(201, createdSection);

    } on FormatException {
       return _jsonErrorResponse(400, 'Invalid JSON format in request body.');
    } catch (e, stackTrace) {
      print('Error creating section: $e\n$stackTrace');
      return _jsonErrorResponse(500, 'Failed to create section.');
    }
  }

  /// Handles PUT /<id> requests to update an existing section.
  Future<Response> _updateSection(Request request, String id) async {
    final sectionId = int.tryParse(id);
    if (sectionId == null) {
      return _jsonErrorResponse(400, 'Invalid section ID format.');
    }

    try {
      // Check if section exists before attempting update
      final checkResult = await _db.query('SELECT id FROM sections WHERE id = @id', substitutionValues: {'id': sectionId});
      if (checkResult.isEmpty) {
        return _jsonErrorResponse(404, 'Section with ID $sectionId not found.');
      }

      final jsonBody = await request.readAsString();
      final Map<String, dynamic> body = jsonDecode(jsonBody);

      // Basic validation
      final validationError = _validateSectionPayload(body);
      if (validationError != null) {
        return _jsonErrorResponse(400, validationError);
      }

      // Create Section instance, ensuring ID from path is used
      final section = Section.fromJson({...body, 'id': sectionId});

      final result = await _db.query(
        '''
        UPDATE sections
        SET title = @title, content = @content, "imageUrl" = @imageUrl, "updatedAt" = CURRENT_TIMESTAMP
        WHERE id = @id
        RETURNING *
        ''',
        substitutionValues: section.toJson(),
      );

      final updatedSection = Section.fromJson(result.first.toColumnMap());
      return _jsonResponse(200, updatedSection);

    } on FormatException {
       return _jsonErrorResponse(400, 'Invalid JSON format in request body.');
    } catch (e, stackTrace) {
      print('Error updating section $sectionId: $e\n$stackTrace');
      return _jsonErrorResponse(500, 'Failed to update section.');
    }
  }

  /// Handles DELETE /<id> requests to delete a section.
  Future<Response> _deleteSection(Request request, String id) async {
    final sectionId = int.tryParse(id);
    if (sectionId == null) {
      return _jsonErrorResponse(400, 'Invalid section ID format.');
    }

    try {
       // Check if section exists before attempting delete
      final checkResult = await _db.query('SELECT id FROM sections WHERE id = @id', substitutionValues: {'id': sectionId});
      if (checkResult.isEmpty) {
        return _jsonErrorResponse(404, 'Section with ID $sectionId not found.');
      }

      final result = await _db.execute(
        'DELETE FROM sections WHERE id = @id',
        substitutionValues: {'id': sectionId},
      );

      // Check if any row was actually deleted
      if (result == 0) {
         // This case might be redundant due to the check above, but good practice
         return _jsonErrorResponse(404, 'Section with ID $sectionId not found.');
      }

      // Return 204 No Content on successful deletion
      return Response(204);

    } catch (e, stackTrace) {
      print('Error deleting section $sectionId: $e\n$stackTrace');
      return _jsonErrorResponse(500, 'Failed to delete section.');
    }
  }

  // --- Helper Methods ---

  /// Helper to create consistent JSON error responses.
  Response _jsonErrorResponse(int statusCode, String message) {
    return Response(
      statusCode,
      body: jsonEncode({'error': message}),
      headers: {'Content-Type': 'application/json'},
    );
  }
  
  /// Helper to create consistent JSON success responses.
  Response _jsonResponse(int statusCode, dynamic body) {
     return Response(
      statusCode,
      body: jsonEncode(body),
      headers: {'Content-Type': 'application/json'},
    );
  }

  /// Basic validation for section payload (title, content, imageUrl).
  String? _validateSectionPayload(Map<String, dynamic> body) {
    if (body['title'] == null || body['title'].toString().trim().isEmpty) {
      return 'Title is required and cannot be empty.';
    }
    if (body['content'] == null || body['content'].toString().trim().isEmpty) {
      return 'Content is required and cannot be empty.';
    }
    if (body['imageUrl'] == null || body['imageUrl'].toString().trim().isEmpty) {
      return 'Image URL is required and cannot be empty.';
    }
    // Basic URL format check (can be enhanced)
    if (!Uri.tryParse(body['imageUrl'])!.hasAbsolutePath ?? true) {
       return 'Invalid Image URL format.';
    }
    return null; // No validation errors
  }
}

